From 3519d230c8bafe834b2dac26ace49fcfba139823 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Mon, 18 May 2015 12:30:37 +0200
Subject: [PATCH] fstab-generator: add x-systemd.requires and
 x-systemd.requires-mounts-for

Currently we have no way how to specify dependencies between fstab
entries (or another units) in the /etc/fstab. It means that users are
forced to bypass fstab and write .mount units manually.

The patch introduces new systemd fstab options:

x-systemd.requires=<PATH>

 - to specify dependence an another mount (PATH is translated to unit name)

x-systemd.requires=<UNIT>

 - to specify dependence on arbitrary UNIT

x-systemd.requires-mounts-for=<PATH ...>

 - to specify dependence on another paths, implemented by
   RequiresMountsFor=. The option may be specified more than once.

For example two bind mounts where B depends on A:

 /mnt/test/A    /mnt/test/A     none    bind,defaults
 /mnt/test/A    /mnt/test/B     none    bind,x-systemd.requires=/mnt/test/A

More complex example with overlay FS where one mount point depends on
"low" and "upper" directories:

 /dev/sdc1   /mnt/low    ext4     defaults
 /dev/sdc2   /mnt/high   ext4     defaults
 overlay     /mnt/merged overlay  lowerdir=/mnt/low,upperdir=/mnt/high/data,workdir=/mnt/high/work,x-systemd.requires-mounts-for=/mnt/low,x-systemd.requires-mounts-for=mnt/high

https://bugzilla.redhat.com/show_bug.cgi?id=812826
https://bugzilla.redhat.com/show_bug.cgi?id=1164334
---
 man/systemd.mount.xml                 | 30 ++++++++++++++
 src/fstab-generator/fstab-generator.c | 77 +++++++++++++++++++++++++++++++++++
 src/shared/fstab-util.c               | 30 ++++++++++++++
 src/shared/fstab-util.h               |  2 +
 4 files changed, 139 insertions(+)

diff --git a/man/systemd.mount.xml b/man/systemd.mount.xml
index 862f42e5943..ffffc56936c 100644
--- a/man/systemd.mount.xml
+++ b/man/systemd.mount.xml
@@ -138,6 +138,36 @@
 
                 <variablelist class='fstab-options'>
 
+      <varlistentry>
+        <term><option>x-systemd.requires=</option></term>
+
+        <listitem><para>Configures a <varname>Requires=</varname> and
+        an <varname>After=</varname> dependency between the created
+        mount unit and another systemd unit, such as a device or mount
+        unit. The argument should be a unit name, or an absolute path
+        to a device node or mount point.  This option may be specified
+        more than once. This option is particularly useful for mount
+        point declarations that need an additional device to be around
+        (such as an external journal device for journal file systems)
+        or an additional mount to be in place (such as an overlay file
+        system that merges multiple mount points). See
+        <varname>After=</varname> and <varname>Requires=</varname> in
+        <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry>
+        for details.</para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>x-systemd.requires-mounts-for=</option></term>
+
+        <listitem><para>Configures a
+        <varname>RequiresMountsFor=</varname> dependency between the
+        created mount unit and other mount units. The argument must be
+        an absolute path. This option may be specified more than once.
+        See <varname>RequiresMountsFor=</varname> in
+        <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry>
+        for details.</para></listitem>
+       </varlistentry>
+
                   <varlistentry>
                     <term><option>x-systemd.automount</option></term>
 
diff --git a/src/fstab-generator/fstab-generator.c b/src/fstab-generator/fstab-generator.c
index 11df81a97ef..302fad37bba 100644
--- a/src/fstab-generator/fstab-generator.c
+++ b/src/fstab-generator/fstab-generator.c
@@ -177,6 +177,102 @@ static int write_idle_timeout(FILE *f, const char *where, const char *opts) {
                 streq(me->mnt_dir, "/usr");
 }
 
+static int fstab_extract_values(const char *opts, const char *name, char ***values) {
+        _cleanup_strv_free_ char **optsv = NULL, **res = NULL;
+        char **s;
+
+        assert(opts);
+        assert(name);
+        assert(values);
+
+        optsv = strv_split(opts, ",");
+        if (!optsv)
+                return -ENOMEM;
+
+        STRV_FOREACH(s, optsv) {
+                const char *arg;
+                int r;
+
+                arg = startswith(*s, name);
+                if (!arg || *arg != '=')
+                        continue;
+                r = strv_extend(&res, arg + 1);
+                if (r < 0)
+                        return r;
+        }
+
+        *values = res;
+        res = NULL;
+
+        return !!*values;
+}
+
+static int write_requires_after(FILE *f, const char *opts) {
+        _cleanup_strv_free_ char **names = NULL, **units = NULL;
+        _cleanup_free_ char *res = NULL;
+        char **s;
+        int r;
+
+        assert(f);
+        assert(opts);
+
+        r = fstab_extract_values(opts, "x-systemd.requires", &names);
+        if (r < 0) {
+                log_warning("Failed to parse options: %s", strerror(-r));
+                return r;
+        }
+        if (r == 0)
+                return 0;
+
+        STRV_FOREACH(s, names) {
+                char *x;
+
+                if (path_is_absolute(*s))
+                        x = unit_name_mangle_with_suffix(*s, MANGLE_NOGLOB, ".mount");
+                else
+                        x = unit_name_mangle(*s, MANGLE_NOGLOB);
+                if (!x)
+                        return log_oom();
+                r = strv_consume(&units, x);
+                if (r < 0)
+                        return log_oom();
+        }
+
+        if (units) {
+                res = strv_join(units, " ");
+                if (!res)
+                        return log_oom();
+                fprintf(f, "After=%1$s\nRequires=%1$s\n", res);
+        }
+
+        return 0;
+}
+
+static int write_requires_mounts_for(FILE *f, const char *opts) {
+        _cleanup_strv_free_ char **paths = NULL;
+        _cleanup_free_ char *res = NULL;
+        int r;
+
+        assert(f);
+        assert(opts);
+
+        r = fstab_extract_values(opts, "x-systemd.requires-mounts-for", &paths);
+        if (r < 0) {
+                log_warning("Failed to parse options: %s", strerror(-r));
+                return r;
+        }
+        if (r == 0)
+                return 0;
+
+        res = strv_join(paths, " ");
+        if (!res)
+                return log_oom();
+
+        fprintf(f, "RequiresMountsFor=%s\n", res);
+
+        return 0;
+}
+
 static int add_mount(
                 const char *what,
                 const char *where,
@@ -251,6 +347,15 @@ static int add_mount(
         if (post && !noauto && !nofail && !automount)
                 fprintf(f, "Before=%s\n", post);
 
+        if (!automount && opts) {
+                 r = write_requires_after(f, opts);
+                 if (r < 0)
+                         return r;
+                 r = write_requires_mounts_for(f, opts);
+                 if (r < 0)
+                         return r;
+        }
+
         if (passno != 0) {
                 if (streq(where, "/usr") && stat("/run/initramfs/fsck-usr", &sb) == 0)
                         ; /* skip /usr fsck if it has already been checked in the initramfs */
@@ -315,6 +420,15 @@ static int add_mount(
                                 "Before=%s\n",
                                 post);
 
+                if (opts) {
+                        r = write_requires_after(f, opts);
+                        if (r < 0)
+                                return r;
+                        r = write_requires_mounts_for(f, opts);
+                        if (r < 0)
+                                return r;
+                }
+
                 fprintf(f,
                         "[Automount]\n"
                         "Where=%s\n",
