Index: os-systemd/src/core/path.c
===================================================================
--- os-systemd.orig/src/core/path.c
+++ os-systemd/src/core/path.c
@@ -232,12 +232,16 @@ static bool path_spec_check_good(PathSpe
 
         case PATH_CHANGED:
         case PATH_MODIFIED:
+                log_debug("%d: source %u, previous_exists %d",
+                                __LINE__, source, s->previous_exists);
                 b = access(s->path, F_OK) >= 0;
                 good = (source != PATH_WAITING_SOURCE_START) &&
                        (source != PATH_WAITING_SOURCE_TRIGGER_NOTIFY) &&
                        (source != PATH_WAITING_SOURCE_COLDPLUG ||
                                 s->previous_exists_deserialized) &&
                         b != s->previous_exists;
+                log_debug("%d: source %u, previous_exists %d, b %d, good %d",
+                                __LINE__, source, s->previous_exists, b, good);
                 s->previous_exists = b;
                 break;
 
@@ -501,10 +505,12 @@ static int path_coldplug(Unit *u) {
 
         if (p->deserialized_state != p->state) {
 
-                if (IN_SET(p->deserialized_state, PATH_WAITING, PATH_RUNNING))
+                if (IN_SET(p->deserialized_state, PATH_WAITING, PATH_RUNNING)) {
+                        log_unit_debug(UNIT(p), "%d: calling path_enter_waiting()",  __LINE__);
                         path_enter_waiting(p, PATH_WAITING_SOURCE_COLDPLUG);
-                else
+                } else {
                         path_set_state(p, p->deserialized_state);
+                }
         }
 
         return 0;
@@ -562,6 +568,9 @@ static void path_enter_running(Path *p,
 
         job_set_activation_details(job, details);
 
+        log_unit_debug(UNIT(p), "%d: setting PATH_RUNNING",
+                        __LINE__);
+
         path_set_state(p, PATH_RUNNING);
         path_unwatch(p);
 
@@ -576,9 +585,13 @@ static bool path_check_good(Path *p, Pat
         assert(p);
         assert(ret_trigger_path);
 
-        LIST_FOREACH(spec, s, p->specs)
-                if (path_spec_check_good(s, source, ret_trigger_path))
+        LIST_FOREACH(spec, s, p->specs) {
+                log_debug("%d: source %u, trigger_path %s", __LINE__, source, *ret_trigger_path);
+                if (path_spec_check_good(s, source, ret_trigger_path)) {
+                        log_debug("%d returning true",  __LINE__);
                         return true;
+                }
+        }
 
         return false;
 }
@@ -594,11 +607,13 @@ static void path_enter_waiting(Path *p,
         /* If the triggered unit is already running, so are we */
         trigger = UNIT_TRIGGER(UNIT(p));
         if (trigger && !UNIT_IS_INACTIVE_OR_FAILED(unit_active_state(trigger))) {
+                log_unit_debug(UNIT(p), "%d: already triggered!",  __LINE__);
                 path_set_state(p, PATH_RUNNING);
                 path_unwatch(p);
                 return;
         }
 
+        log_unit_debug(UNIT(p), "%d: source %u", __LINE__, source);
         if (path_check_good(p, source, &trigger_path)) {
                 log_unit_debug(UNIT(p), "Got triggered.");
                 path_enter_running(p, trigger_path);
@@ -617,6 +632,7 @@ static void path_enter_waiting(Path *p,
         if (source != PATH_WAITING_SOURCE_TRIGGER_NOTIFY)
                 source = PATH_WAITING_SOURCE_DISPATCH_IO;
 
+        log_unit_debug(UNIT(p), "%d: source %u", __LINE__, source);
         if (path_check_good(p, source, &trigger_path)) {
                 log_unit_debug(UNIT(p), "Got triggered.");
                 path_enter_running(p, trigger_path);
@@ -659,6 +675,7 @@ static int path_start(Unit *u) {
         path_mkdir(p);
 
         p->result = PATH_SUCCESS;
+        log_unit_debug(u, "%d: calling path_enter_waiting()",  __LINE__);
         path_enter_waiting(p, PATH_WAITING_SOURCE_START);
 
         return 1;
@@ -670,6 +687,7 @@ static int path_stop(Unit *u) {
         assert(p);
         assert(IN_SET(p->state, PATH_WAITING, PATH_RUNNING));
 
+        log_unit_debug(u, "%d: calling path_enter_dead()",  __LINE__);
         path_enter_dead(p, PATH_SUCCESS);
         return 1;
 }
@@ -697,6 +715,8 @@ static int path_serialize(Unit *u, FILE
                                              type,
                                              s->previous_exists,
                                              escaped);
+                log_unit_debug(u, "%d serialized previous_exists %d",
+                                __LINE__, s->previous_exists);
         }
 
         return 0;
@@ -739,6 +759,9 @@ static int path_deserialize_item(Unit *u
                         ssize_t l;
                         PathType type;
 
+                        log_unit_debug(u, "%d deserialized previous_exists %d",
+                                        __LINE__, previous_exists);
+
                         type = path_type_from_string(type_str);
                         if (type < 0) {
                                 log_unit_warning(u, "Unknown path type \"%s\", ignoring.", type_str);
